<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring自动装配]]></title>
    <url>%2F2019%2F07%2F21%2FSpring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Spring的自动装配功能：自动装配：Spring利用依赖注入（DI），完成对IOC容器中各种组件的依赖关系赋值@Autowired的使用场景在构造器（CONSTRUCTOR），参数（PARAMETER），方法（METHOD），属性（FIELD），注释类型（ANNOTATION_TYPE）上，都能使用这个注解{@link Autowired}。且都是从容器中获取参数组件的值 标注在构造器上：默认加载在ioc容器中的组件，容器启动会调用无参构造器创建对象，再进行初始化赋值等操作。 构造器要用的组件，都是从容器中获取。如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取。 12345678910@Componentpublic class PersonService &#123; private Student student; @Autowired //可以省略 public PersonService(Student student)&#123; this.student = student; System.out.println("PersonService 有参构造器。。。"); &#125;&#125; 标注在参数上： 12345678@Componentpublic class PersonService &#123; private Student student; public PersonService(@Autowired Student student)&#123; this.student = student; &#125;&#125; 标注在方法上：Spring容器创建当前对象，就会调用方法，完成赋值；方法使用的参数，自定义类型的值从ioc容器中获取。常用的有：@Bean + 方法参数，参数从容器中获取 1234567891011121314@Componentpublic class PersonService &#123; private Student student; /** * * @param student 这里方法的参数（student）的值，从ioc容器中获取 * @return */ @Autowired public Student getStudent(Student student) &#123; return this.student = student; &#125;&#125; @Autowired的详细使用 默认优先按照类型去容器中找对应的组件。 1annotationConfigApplicationContext.getBean(BookDao.class); 如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找。 12345 /** * 这里bookDao为注入的属性名 */annotationConfigApplicationContext.getBean("bookDao") @Qualifier(“bookDao)：使用@Qualifier指定需要装配的组件的id，而不是使用属性名。 自动装配默认一定要将属性赋值好，如果没有就会报错。 @Autowired(required = true)，required默认为true，改为false后就不会报错 @Primary：让Spring进行自动装配的时候，默认使用首先的bean，也可以继续使用@Qualifier指定需要装配的bean的名字 @Autowired是Spring规范的注解，同时Spring还支持java规范的注解：@Resource（JSR250规范）和@Inject(JSR330规范) @Resource 可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的，不支持@Primary,也不支持@Autowired（require=false） @Inject 需要导入javax的包，和Autowired的功能一样。没有require=false的功能]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 注册组件的几种方式]]></title>
    <url>%2F2019%2F07%2F14%2FSpring-%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在Spring中，给容器注册组件有多种方式，从之前的xml配置到后来的全注解配置，省去了复杂繁琐的xml配置，给开发人员带来的极大便利。给容器中注册组件的几种方式：1、包扫描 + 组件标注注解（@Controller、@Service、@Repository、@Component）2、@Bean（导入第三方包里面的组件，比如RestTemplate）3、@Import（快速给容器中导入一个组件） @Import（要导入到容器的组件）；容器中就会自动注册这个组件，id默认是全类名 实现ImportSelector类：返回需要导入的组件的全类名数组 实现ImportBeanDefinitionRegistrar：手动注册bean到容器中 4、使用Spring提供的FactoryBean(工厂Bean)]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis foreach循环 collection的三种方式]]></title>
    <url>%2F2019%2F07%2F13%2FMybatis-foreach%E5%BE%AA%E7%8E%AF-collection%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[自从有了Mybatis加强版Mybatis,再也不用写那么复杂麻烦的xml配置文件了！但是偶尔也有需求还得用xml，对于Mybatis的foreach也是经常用到的，但是每次都是从项目里粘贴复制、修修改改就用，对于其具体使用理解也是模模糊糊，导致有时用到的时候遇到各种问题，此文就针对Mybatis的foreach做个记录，以便更透彻的理解与使用。foreach标签主要用于构建in条件，它可以在sql中对集合进行迭代，通常可以将之用到批量删除、添加等操作中，示例如下： 1234567891011&lt;select id="getRequestLogList" parameterType="java.util.HashMap" resultType="RequestLog"&gt; SELECT * FROM request_log &lt;where&gt; &lt;if test="sessionIdList !=null and sessionIdList.size &gt; 0"&gt; and sessionId in ( &lt;foreach collection="sessionIdList" item="item" index="index" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 加入我们输入的参数为 Long sessionIdList[] = {1L, 2L, 4L}; 那么对应执行的sql就是 ： 1SELECT * FROM request_log where sessionId in (1, 2, 4); foreach元素的属性主要有 item，index，collection，open，separator，close。 ​ item：表示集合中每一个元素进行迭代时的别名， ​ index：指 定一个名字，用于表示在迭代过程中，每次迭代到的位置， ​ open：表示该语句以什么开始， ​ separator：表示在每次进行迭代之间以什么符号作为分隔 符， ​ close：表示以什么结束。 在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况 下，该属性的值是不一样的，主要有一下3种情况： ​ 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list ​ 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array ​ 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可 1、collection属性为List方法调用 123public List&lt;Area&gt; findUserListByIdList(List&lt;Long&gt; idList) &#123; return getSqlSession().findUserListByIdList(idList); &#125; 对应的mapper： 123456789&lt;select id="findUserListByIdList" parameterType="java.util.ArrayList" resultType="User"&gt; select * from user &lt;where&gt; ID in ( &lt;foreach collection="list" item="guard" index="index" separator=","&gt; #&#123;guard&#125; &lt;/foreach&gt; ) &lt;/where&gt; &lt;/select&gt; 即单独传入list时，foreach中的collection必须是 list，不管变量的具体名称是什么。比如这里变量名为idList， collection却是List。 2、collection属性为array方法调用 123public List&lt;Area&gt; findUserListByIdList(int[] ids) &#123; return getSqlSession().findUserListByIdList(ids); &#125; 对应的mapper： 123456789&lt;select id="findUserListByIdList" parameterType="java.util.HashList" resultType="User"&gt; select * from user &lt;where&gt; ID in ( &lt;foreach collection="array" item="guard" index="index" separator=","&gt; #&#123;guard&#125; &lt;/foreach&gt; ) &lt;/where&gt; &lt;/select&gt; 单独传入数组时，foreach中的collection必须是 array，不管变量的具体名称是什么。比如这里变量名为ids，collection却是array。 3、collection属性为map方法调用： 12345public boolean exists(Map&lt;String, Object&gt; map)&#123; Object count = getSqlSession().exists(map); int totalCount = Integer.parseInt(count.toString()); return totalCount &gt; 0 ? true : false; &#125; 对应的mapper： 1234567891011121314151617&lt;select id="exists" parameterType="java.util.HashMap" resultType="java.lang.Integer"&gt; SELECT COUNT(*) FROM USER user &lt;where&gt; &lt;if test="code != null"&gt; and CODE = #&#123;code&#125; &lt;/if&gt; &lt;if test="id != null"&gt; and ID = #&#123;id&#125; &lt;/if&gt; &lt;if test="idList !=null "&gt; and ID in ( &lt;foreach collection="idList" item="guard" index="index" separator=","&gt; #&#123;guard&#125; &lt;/foreach&gt; ) &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; map中有list或array时，foreach中的collection必须是具体list或array的变量名。比如这里map含有一个名为idList的list，所以map中用idList(map的key)来取值，这点和单独传list或array时不太一样。 4、传入java对象调用方法 12345public boolean findUserListByDTO(UserDTO userDTO)&#123; Object count = getSqlSession().findUserListByDTO(userDTO); int totalCount = Integer.parseInt(count.toString()); return totalCount &gt; 0 ? true : false; &#125; 对应的mapper： 1234567891011121314151617select id="findUserListByDTO" parameterType="UserDTO" resultType="java.lang.Integer"&gt; SELECT COUNT(*) FROM USER user &lt;where&gt; &lt;if test="code != null"&gt; and CODE = #&#123;code&#125; &lt;/if&gt; &lt;if test="id != null"&gt; and ID = #&#123;id&#125; &lt;/if&gt; &lt;if test="idList !=null "&gt; and ID in ( &lt;foreach collection="idList" item="guard" index="index" separator=","&gt; #&#123;guard&#125; &lt;/foreach&gt; ) &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; JAVA对象中有list或array时，foreach中的collection必须是具体list或array的变量名。比如这里UserDTO含有一个名为idList的list，所以UserDTO中用idList取值，这点和单独传list或array时不太一样。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis foreach 使用错误记录]]></title>
    <url>%2F2019%2F07%2F13%2FMybatis-foreach-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[使用Mybatis foreach遍历时，Error evaluating expression ‘sessionIdList’. Return value () was not iterable.问题的起因时这样的，同事用map方式传值，map里需要存入一个集合，但是在判断集合为空时放了空字符串，导致mybatis在遍历时无法把空字符串解析成集合。 传入map 1234567891011HashMap&lt;String, Object&gt; mapper = new HashMap&lt;String, Object&gt;(16);// 获取要遍历的sessionIdList集合List&lt;Long&gt; list = getSessionIdList();if (CollectionUtils.isEmpty(list)) &#123; mapper.put(&quot;sessionIdList&quot;, &quot;&quot;); //罪魁祸首在这里&#125; else &#123; mapper.put(&quot;sessionIdList&quot;, list);&#125;List&lt;RequestLog&gt; requestLogList = requestLogService.getRequestLogList(mapper); 对应mapper 1234567891011121314151617&lt;select id=&quot;getRequestLogList&quot; parameterType=&quot;java.util.HashMap&quot; resultType=&quot;RequestLog&quot;&gt; SELECT * FROM USER request_log &lt;where&gt; &lt;if test=&quot;code != null and code != &apos;&apos; &quot;&gt; and CODE = #&#123;code&#125; &lt;/if&gt; &lt;if test=&quot;id != null and id != &apos;&apos;&quot;&gt; and ID = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;sessionIdList !=null and sessionIdList.size &gt; 0&quot;&gt; and sessionId in ( &lt;foreach collection=&quot;sessionIdList&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 当调用getSessionIdList()方法获取到的集合为空时，传入的值是空字符串而非集合类型，从而在mapper.xml中解析时无法把字符串类型解析成集合类型，报出了Return value () was not iterable的问题。 另外还发现了另一个问题，在判断mapper.xm中集合是否为空时，不能与空字符串比较进行判断，而应该用size方法，否则会引起 invalid comparison: java.util.ArrayList and java.lang.String 把集合类型与字符串类型作比较，引起了“无效的比较”错误 反例 123456&lt;if test=&quot;sessionIdList !=null and sessionIdList != &apos;&apos;&quot;&gt; &lt;!--这里用!=&apos;&apos; 进行判断会报错，因为引起了集合与String类型的比较--&gt; and sessionId in ( &lt;foreach collection=&quot;sessionIdList&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/if&gt; 正例123456&lt;if test=&quot;sessionIdList !=null and sessionIdList.size &gt; 0 &apos;&apos;&quot;&gt; &lt;!--这里应该用sessionIdList.size &gt; 0 来判断集合是否为空--&gt; and sessionId in ( &lt;foreach collection=&quot;sessionIdList&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; ) &lt;/if&gt; 总结当用mabatis foreach遍历时，遍历对象的类型一定要确认是否正确。一般有三种：list(集合)、array(数组)、map(map中传入集合)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
</search>
